//
// Copyright (c) 2025 Emilio Mariscal
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file geobuilder.cc
/// \brief This file is used to build geometries


// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <map>
#include <string>
#include <iostream>
#include <boost/timer/timer.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/timer/timer.hpp>
#include "utils/log.hh"
#include "data/pq.hh"
#include "raw/queryraw.hh"
#include "raw/geobuilder.hh"
#include "osm/osmobjects.hh"
#include "osm/osmchange.hh"
#include <boost/algorithm/string/join.hpp>
#include <boost/range/adaptor/transformed.hpp>

using namespace pq;
using namespace geobuilder;
using namespace logger;
using namespace osmobjects;
using namespace queryraw;
using namespace osmchange;
namespace bg = boost::geometry;


/// \namespace geobuilder
namespace geobuilder {

GeoBuilder::GeoBuilder(multipolygon_t &_poly, const std::shared_ptr<QueryRaw> &queryraw) :
    poly(_poly), queryraw(queryraw) {}

GeoBuilder::~GeoBuilder() = default;

// Receives a list of Osm Changes and the priority area and completes the geometry of
// all objects (Nodes, Ways and Relations), including all indirectly modified objects.
void
GeoBuilder::buildGeometries(std::shared_ptr<OsmChangeFile> &osmchanges)
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("buildGeometries(osmchanges, poly): took %w seconds\n");
#endif
    // Pre-process changes, keeping track of:
    // - Nodes: referenced and modified 
    // - Ways: removed and modified 
    // - Relations: removed 
    preProcessChanges(osmchanges);

    // Add indirectly modified features
    addIndirectlyModifiedWays(osmchanges);
    addIndirectlyModifiedRelations(osmchanges);

    // Fill fill caches and build geometries
    fillNodeCache(osmchanges);
    buildWays(osmchanges);
    fillWayCache(osmchanges);
    buildRelations(osmchanges);
}

// Join a vector of long numbers and return a comma separated string
std::string joinIds(const std::vector<long>& vec) {
    using namespace boost::adaptors;
    auto asStrings = vec | transformed([](long v) { return std::to_string(v); });
    return boost::algorithm::join(asStrings, ",");
}

void
GeoBuilder::preProcessChanges(std::shared_ptr<OsmChangeFile> &osmchanges) {
    for (const auto& changePtr : osmchanges->changes) {
        if (!changePtr) continue;

        auto& ways = changePtr->ways;
        for (const auto& way : ways) {
            if (!way) continue;

            if (way->action != osmobjects::remove) {

                // Keep track of modified ways
                if (way->action == osmobjects::modify) {
                    modifiedWaysIds.push_back(way->id);
                    waycache.insert(std::make_pair(way->id, way));
                }

                // Save referenced Nodes ids for later use. The geometries of these
                // Nodes will be needed later when building geometries for Ways
                for (const auto& ref : way->refs) {
                    if (!nodecache.count(ref)) {
                        referencedNodeIds.push_back(ref);
                    }
                }

            // Keep track of removed ways
            } else {
                // Save removed Ways for later use. This list will be used to known
                // which Ways will be skipped when building geometries
                removedWays.push_back(way->id);
            }
        }

        // Save modified nodes for later use. This list will be used for getting
        // indirectly modified Ways
        auto& nodes = changePtr->nodes;
        for (const auto& node : nodes) {
            if (!node) continue;
            if (node->action == osmobjects::modify) {
                // Get only modified nodes ids inside the priority area
                if (poly.empty() || bg::within(node->point, poly)) {
                    modifiedNodesIds.push_back(node->id);
                }
            }
        }

        // Save removed Relations for later use. This list will be used to known
        // which Relations will be skipped when building geometries
        auto& relations = changePtr->relations;
        for (const auto& relation : relations) {
            if (!relation) continue;
            removedRelations.push_back(relation->id);

            // Keep track of modified relations
            if (relation->action == osmobjects::modify) {
                modifiedRelsIds.push_back(relation->id);
            }

        }
    }
}

// Incomplete geometries happens all the time on Ways and Relations because the data for
// their geometries (coordinates) can be not present on the OsmChange file. For example
// if the tags of a Way are modified, but not its references, only the tag information
// will be on the OsmChange file, but not the coordinates for the referenced Nodes.
//
// An indirectly modified object is the one whose geometry was modified by a modification
// on the geometry of one of its references. For example, if a Node is modified and that
// Node is referenced on a Way, the Way's geometry must to be updated. Also, if that Way
// is referenced on a Relation, then the Relation's geometry must be updated too.

void
GeoBuilder::addIndirectlyModifiedWays(std::shared_ptr<OsmChangeFile> &osmchanges) {
    // Add indirectly modified ways to osmchanges. An indirectly modified Way is a Way
    // whose geoemtry was modified because one of it's referenced Nodes was modified

    if (modifiedNodesIds.size() > 0) {

        // Get all Ways that have at least one reference to one of the modified Nodes
        auto indirectlyModifiedWays = queryraw->getWaysByNodesRefs(joinIds(modifiedNodesIds));

        // Add a new change for the indirectly modified Way
        auto change = std::make_shared<OsmChange>(none);
        for (const auto& way : indirectlyModifiedWays) {
           // If the Way wasn't removed or modified
           if (
                std::find(removedWays.begin(), removedWays.end(), way->id) == removedWays.end() &&
                std::find(modifiedWaysIds.begin(), modifiedWaysIds.end(), way->id) == modifiedWaysIds.end()
            ) {

                // Save referenced Nodes. This list will be used for getting the geometries of
                // these Nodes, used when building the Way geometry
                for (const auto& ref : way->refs) {
                    if (!nodecache.count(ref)) {
                        referencedNodeIds.push_back(ref);
                    }
                }

                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                way->action = osmobjects::modify_geom;

                // Add the Way to the list of Ways in the OsmChange
                change->ways.push_back(way);

                // Save the id of the indirectly modified Way for later use. This will be used
                // for identifying which Relations were indirectly modified by this change.
                modifiedWaysIds.push_back(way->id);
           }
        }
        osmchanges->changes.push_back(change);
    }
}

void
GeoBuilder::addIndirectlyModifiedRelations(std::shared_ptr<OsmChangeFile> &osmchanges) {
    // Add indirectly modified Relations to osmchanges. This is the case when a Way referenced
    // in a Relation was modified (or indirectly modified by a change on one of its Nodes)
    if (modifiedWaysIds.size() > 0) {

        // Get indirectly modified Relations from the DB, using the list of Ways
        // that were modified
        auto indirectlyModifiedRelations = queryraw->getRelationsByWaysRefs(joinIds(modifiedWaysIds));

        // Create a new change for the indirecty modified Relation
        auto change = std::make_shared<OsmChange>(none);
        for (const auto& relation : indirectlyModifiedRelations) {
           // If the Relation // wasn't removed or modified
           if (
                std::find(removedRelations.begin(), removedRelations.end(), relation->id) == removedRelations.end() &&
                std::find(modifiedRelsIds.begin(), modifiedRelsIds.end(), relation->id) == modifiedRelsIds.end()
            ) {
                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                relation->action = osmobjects::modify_geom;

                // Add the Relation to the list of Relation in the OsmChange
                change->relations.push_back(relation);
           }
        }
        osmchanges->changes.push_back(change);
    }
}

void
GeoBuilder::fillNodeCache(std::shared_ptr<OsmChangeFile> &osmchanges) {

    // Fill node cache with nodes in osmchanges
    for (const auto& change : osmchanges->changes) {
        for (const auto& node : change->nodes) {
            nodecache.insert(std::make_pair(node->id, node));
        }
    }

    // Fill nodecache with referenced Nodes. This will be used later when building the
    // geometries of Ways
    if (referencedNodeIds.size() > 0) {
        // Get Nodes geometries
        auto result = queryraw->getNodesByIds(joinIds(referencedNodeIds));
        // Fill nodecache
        for (const auto& node : result) {
            nodecache.insert(std::make_pair(node->id, node));
         }
    }
}

void
GeoBuilder::fillWayCache(std::shared_ptr<OsmChangeFile> &osmchanges) {
    if (modifiedWaysIds.size() > 0) {
        // Get geometries for all modified Ways
        auto ways = queryraw->getWaysByIds(joinIds(modifiedWaysIds));
        for (const auto& w : ways) {
            waycache.insert(std::make_pair(w->id, w));
        }
    }
}

void
GeoBuilder::buildWays(std::shared_ptr<OsmChangeFile> &osmchanges) {
     // Build Ways geometries using nodecache
    for (const auto& change : osmchanges->changes) {
        for (const auto& way : change->ways) {
            // Only build geometries for Ways with incomplete geometries
            if (bg::num_points(way->linestring) != way->refs.size()) {
                way->linestring.clear();
                for (const auto& ref : way->refs) {
                    if (nodecache.count(ref)) {
                        bg::append(way->linestring, nodecache.at(ref)->point);
                    }
                }
                if (way->isClosed()) {
                    way->polygon = { {std::begin(way->linestring), std::end(way->linestring)} };
                    way->linestring.clear();
                }
            }

            // Save Way pointer for later use. This will be used when building Relations geometries.
            if (poly.empty() || bg::within(way->linestring, poly)) {
                if (waycache.count(way->id)) {
                    if (way->isClosed()) {
                        waycache.at(way->id)->polygon = way->polygon;
                    } else {
                        waycache.at(way->id)->linestring = way->linestring;
                    }
                } else {
                    waycache.insert(std::make_pair(way->id, way));
                }
            }

        }
    }
}

void
GeoBuilder::buildRelations(std::shared_ptr<OsmChangeFile> &osmchanges) {
    // Build list of Relations that have missing geometries. This list will be used for
    // querying the database and get the geometries of the referenced Ways .
    std::vector<long> relsForWayCacheIds;
    for (const auto& change : osmchanges->changes) {
        for (const auto& relation : change->relations) {
            if (relation->action != osmobjects::remove) {
                for (const auto& member : relation->members) {
                    if (member.type == osmobjects::way && !waycache.count(member.ref)) {
                        relsForWayCacheIds.push_back(member.ref);
                    }
                }
            }
        }
    }

    // Get the geometries of the referenced Ways from the DB.
    if (relsForWayCacheIds.size() > 0) {
        auto ways = queryraw->getWaysByIds(joinIds(relsForWayCacheIds));
        for (const auto& w : ways) {
            waycache.insert(std::make_pair(w->id, w));
        }
    }

    // Build geometries for Relations (Polygon or MultiLinestring)
    for (const auto& change : osmchanges->changes) {
        for (const auto& relation : change->relations) {
            // Skip removed relations
            if (relation->action != osmobjects::remove) {
                buildRelationGeometry(*relation);
            }
        }
    }
}

void
GeoBuilder::buildRelationGeometry(osmobjects::OsmRelation &relation) {

    std::vector<RelationGeometry> parts_inner;
    std::vector<RelationGeometry> parts_outer;
    linestring_t part;
    linestring_t lastLinestring;
    bool justClosed = false;
    bool first = true;

    std::vector<osmobjects::OsmRelationMember> members;

    // Skip members that are not Way
    for (const auto& member : relation.members) {
        if (member.type == osmobjects::way) {
            members.push_back(member);
        }
    }

    for (auto mit = members.begin(); mit != members.end(); ++mit) {
        // Process Way objects only, not Nodes or other Relations
        if (!waycache.count(mit->ref)) {
            // Way is not available in cache,
            // possibily because Relation is not in the priority area
            // or the way was deleted
            return;
        }

        auto way = std::make_shared<osmobjects::OsmWay>();

        way = waycache.at(mit->ref);

        if (bg::num_points(way->linestring) > 0 &&
            bg::num_points(way->polygon) == 0)
        {

            // Linestrings

            if (!way->isClosed()) {

                // Reverse the line direction if it's necessary
                if (first && (std::next(mit) != members.end())) {
                    auto nextWay = std::make_shared<osmobjects::OsmWay>();
                    auto nextWayId = std::next(mit)->ref;
                    if (!waycache.count(nextWayId)) {
                        // Way is not available in cache,
                        // possibily because Relation is not in the priority area
                        // or the way was deleted
                        return;
                    }
                    nextWay = waycache.at(nextWayId);

                    if ( bg::num_points(nextWay->linestring) > 0 && 
                        bg::num_points(way->linestring) > 0 && (
                        bg::equals(way->linestring.front(), nextWay->linestring.front()) ||
                        bg::equals(way->linestring.front(), nextWay->linestring.back())
                    )) {
                        bg::reverse(way->linestring);
                    }
                } else {
                    if ( bg::num_points(way->linestring) > 0 &&
                         bg::num_points(lastLinestring) > 0 ) {
                        if (bg::equals(way->linestring.back(), lastLinestring.back())) {
                            bg::reverse(way->linestring);
                        }
                    }
                }

                bg::append(part, way->linestring);

                // Check if object is closed
                if (relation.isMultiPolygon() && bg::equals(part.back(), part.front())) {
                    // Convert LineString to Polygon
                    polygon_t polygon;
                    bg::append(polygon.outer(), part);
                    if (mit->role == "inner") {
                        parts_inner.push_back({
                            linestring_t(),
                            { polygon }
                        });
                    } else {
                        parts_outer.push_back({
                            linestring_t(),
                            { polygon }
                        });
                    }
                    part.clear();
                    first = true;
                    justClosed = true;
                    lastLinestring.clear();
                } else if (std::next(mit) != members.end()) {
                    // Check if object is disconnected
                    auto nextWay = std::make_shared<osmobjects::OsmWay>();
                    auto nextWayId = std::next(mit)->ref;
                    if (!waycache.count(nextWayId)) {
                        // Way is not available in cache,
                        // possibily because Relation is not in the priority area
                        // or the way was deleted
                        return;
                    }
                    nextWay = waycache.at(nextWayId);
                    if ( (bg::num_points(way->linestring) > 0 && bg::num_points(nextWay->linestring) > 0 &&
                        !bg::equals(way->linestring.back(), nextWay->linestring.front()) &&
                        !bg::equals(way->linestring.back(), nextWay->linestring.back())) ||
                        (bg::num_points(nextWay->linestring) == 0)
                    ) {
                        parts_outer.push_back({
                            { part },
                            polygon_t()
                        });
                        part.clear();
                        first = true;
                        justClosed = true;
                        lastLinestring.clear();
                    }
                }


            } else {
                // Convert LineString to Polygon
                if (mit->role == "inner") {
                    parts_inner.push_back({
                        linestring_t(),
                        { way->polygon }
                    });
                } else {
                    parts_outer.push_back({
                        linestring_t(),
                        { way->polygon }
                    });
                }
            }

            lastLinestring = way->linestring;

        } else {

            // Polygons

            // When Relation is MultiLineString but way's geometry is a Polygon
            if (!relation.isMultiPolygon() && bg::num_points(way->linestring) == 0 &&
                bg::num_points(way->polygon) > 0
            ) {
                // Convert way's Polygon to LineString
                bg::assign_points(way->linestring, way->polygon.outer());
                if (mit->role == "inner") {
                        parts_inner.push_back({
                            { way->linestring },
                            polygon_t()
                        });
                } else {
                        parts_outer.push_back({
                            { way->linestring },
                            polygon_t()
                        });
                }
            } else {
                if (mit->role == "inner") {
                    parts_inner.push_back({
                        linestring_t(),
                        { way->polygon }
                    });
                } else {
                    if (way->polygon.outer().size() > 0) {
                        parts_outer.push_back({
                            linestring_t(),
                            { way->polygon }
                        });
                    } else {
                        parts_outer.push_back({
                            { way->linestring },
                            polygon_t()
                        });
                    }
                }
            }

        }

        if (first && !justClosed) {
            first = false;
        }
        if (justClosed) {
            justClosed = false;
        }

    }

    if (part.size() > 0) {
        parts_outer.push_back({
            { part },
            polygon_t()
        });
    }

    // Converts all geometries to WKT strings

    std::string geometry = "";
    int i = 0;

    // Inner parts
    for (auto pit = parts_outer.begin(); pit != parts_outer.end(); ++pit) {
        std::stringstream ss;
        std::string geometry_str;
        ++i;
        if (relation.isMultiPolygon()) {
            if (bg::num_points(pit->polygon.outer()) > 1) {
                ss << std::setprecision(12) << bg::wkt(pit->polygon);
                geometry_str = ss.str();
                // Erase "POLYGON("
                geometry_str.erase(0,8);
                geometry_str.erase(geometry_str.size() - 1);
                geometry += geometry_str + ",";
            }
        } else {
            if (bg::num_points(pit->linestring) > 1) {
                ss << std::setprecision(12) << bg::wkt(pit->linestring);
                geometry_str = ss.str();
                // Erase "LINESTRING("
                geometry_str.erase(0,11);
                geometry_str.erase(geometry_str.size() - 1);
                geometry += "(" + geometry_str + "),";
            }
        }
    }

    // Outer parts
    for (auto pit = parts_inner.begin(); pit != parts_inner.end(); ++pit) {
        std::stringstream ss;
        std::string geometry_str;
        ++i;
        if (relation.isMultiPolygon()) {
            if (bg::num_points(pit->polygon.outer()) > 1) {
                ss << std::setprecision(12) << bg::wkt(pit->polygon);
                geometry_str = ss.str();
                // Erase "POLYGON("
                geometry_str.erase(0,8);
                geometry_str.erase(geometry_str.size() - 1);
                geometry += geometry_str + ",";
            }
        } else {
            if (bg::num_points(pit->linestring) > 1) {
                ss << std::setprecision(12) << bg::wkt(pit->linestring);
                geometry_str = ss.str();
                // Erase "LINESTRING("
                geometry_str.erase(0,11);
                geometry_str.erase(geometry_str.size() - 1);
                geometry += "(" + geometry_str + "),";
            }
        }
    }

    // Build the final multipolygon or multilinestring to store it as the
    // relation's geometry 
    if (geometry.size() > 1) {
        geometry.erase(geometry.size() - 1);
        if (relation.isMultiPolygon()) {
            bg::read_wkt("POLYGON(" + geometry + ")", relation.multipolygon);
        } else {
            bg::read_wkt("MULTILINESTRING(" + geometry + ")", relation.multilinestring);
        }
    }
}


}  // namespace geobuilder

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
