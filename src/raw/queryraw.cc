//
// Copyright (c) 2023, 2024 Humanitarian OpenStreetMap Team
// Copyright (c) 2025 Emilio Mariscal
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file queryraw.cc
/// \brief This file is used to work with the OSM Raw database
///
/// This manages the OSM Raw schema in a PostgreSQL database, 
/// including querying existing data in the database, as well as
/// updating the database.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <map>
#include <string>
#include <iostream>
#include <boost/timer/timer.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/timer/timer.hpp>
#include "utils/log.hh"
#include "data/pq.hh"
#include "raw/queryraw.hh"
#include "osm/osmobjects.hh"
#include "osm/osmchange.hh"

using namespace pq;
using namespace logger;
using namespace osmobjects;
using namespace osmchange;
namespace bg = boost::geometry;

/// \namespace queryraw
namespace queryraw {

const std::string QueryRaw::polyTable = "ways_poly";
const std::string QueryRaw::lineTable = "ways_line";

QueryRaw::QueryRaw(std::shared_ptr<Pq> db) {
    dbconn = db;
    utils = std::make_shared<DataUtils>(db);
}

// Apply change functions receive an OSM feature
// and return a DB query for insert, update or delete

// Apply the change for a Node.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmNode &node) const
{
    auto queries = std::make_shared<std::vector<std::string>>();

    // If create or modify, then insert or update
    if ((node.action == osmobjects::create || node.action == osmobjects::modify)) {
        std::string query = "INSERT INTO nodes AS r (osm_id, geom, tags, timestamp, version, \"user\", uid, changeset) VALUES(";
        std::string format = "%d, ST_GeomFromText(\'%s\', 4326), %s, \'%s\', %d, \'%s\', %d, %d)";

        format.append(" ON CONFLICT (osm_id) DO UPDATE SET geom = ST_GeomFromText(\'%s\', \
        4326), tags = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version < %d;");

        boost::format fmt(format);

        log_debug("Create or modify Node %1%", node.id);

        // osm_id
        fmt % node.id;

        // geometry
        std::stringstream ss;
        ss << std::setprecision(12) << bg::wkt(node.point);
        std::string geometry = ss.str();
        fmt % geometry;

        // tags
        auto tags = utils->buildTagsQuery(node.tags);
        fmt % tags;
        // timestamp
        std::string timestamp;
        if (node.timestamp != not_a_date_time) {
            timestamp = to_simple_string(node.timestamp);
        } else {
            timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
        }

        fmt % timestamp;
        // version
        fmt % node.version;
        // user
        fmt % dbconn->escapedString(node.user);
        // uid
        fmt % node.uid;
        // changeset
        fmt % node.changeset;

        // ON CONFLICT (update)
        fmt % geometry;
        fmt % tags;
        fmt % timestamp;
        fmt % node.version;
        fmt % dbconn->escapedString(node.user);
        fmt % node.uid;
        fmt % node.changeset;
        fmt % node.version;

        query.append(fmt.str());
        queries->push_back(query);

    // If remove, then delete the object
    } else if (node.action == osmobjects::remove) {
        queries->push_back("DELETE FROM nodes WHERE osm_id = " + std::to_string(node.id) + ";");
        log_debug("Delete Node %1%", node.id);
    }

    return queries;
}

// Apply the change for a Way.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmWay &way) const
{
    auto queries = std::make_shared<std::vector<std::string>>();

    // Make sure we have what's needed to insert or update a Way:
    // - At least 2 points
    // - A LineString or a Polygon
    // - A create, modify or "modify geometry" action.
    if ((bg::num_points(way.linestring) >= 2 || bg::num_points(way.polygon) >= 2)
        && (way.action == osmobjects::create || way.action == osmobjects::modify
        || way.action == osmobjects::modify_geom)) {

        if ((way.refs.front() != way.refs.back() && way.refs.size() == bg::num_points(way.linestring)) ||
            (way.refs.front() == way.refs.back() && way.refs.size() == bg::num_points(way.polygon))
         ) {

            std::string query;
            const std::string* tableName;
            std::stringstream ss;

            // Get a Polygon or LineString geometry string depending on the Way's geometry
            if (way.isClosed()) {
                tableName = &QueryRaw::polyTable;
                ss << std::setprecision(12) << bg::wkt(way.polygon);
            } else {
                tableName = &QueryRaw::lineTable;
                ss << std::setprecision(12) << bg::wkt(way.linestring);
            }
            std::string geostring = ss.str();

            // Insert or update the full Way, including id, tags, refs, geometry, timestamp, version,
            // user, uid and changeset
            if (way.action != osmobjects::modify_geom) {

                log_debug("Create or modify Way %1%", way.id);

                query = "INSERT INTO " + *tableName + " AS r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d)";

                format.append(" ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;");

                boost::format fmt(format);

                // osm_id
                fmt % way.id;

                // tags
                auto tags = utils->buildTagsQuery(way.tags);
                fmt % tags;

                // refs
                std::string refs = "";
                for (auto it = std::begin(way.refs); it != std::end(way.refs); ++it) {
                    refs += std::to_string(*it) + ",";
                }
                refs.erase(refs.size() - 1);
                refs = "ARRAY[" + refs + "]";
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp
                std::string timestamp;
                if (way.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(way.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }

                fmt % timestamp;
                // version
                fmt % way.version;
                // user
                fmt % dbconn->escapedString(way.user);
                // uid
                fmt % way.uid;
                // changeset
                fmt % way.changeset;

                // ON CONFLICT (update)
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % way.version;
                fmt % dbconn->escapedString(way.user);
                fmt % way.uid;
                fmt % way.changeset;
                fmt % way.version;

                query += fmt.str();
                queries->push_back(query);

            } else {

                // Update only the Way's geometry. This is the case when a Way was indirectly 
                // modified by a change on some referenced Node; the geometry of the Way will
                // change but all other data (tags, version, etc) will remain the same.

                log_debug("Modify geometry of Way %1%", way.id);

                query = "UPDATE " + *tableName + " SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp
                std::string timestamp;
                if (way.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(way.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;

                // osm_id
                fmt % way.id;

                query += fmt.str();
                queries->push_back(query);
            }

            // If the Way's geometry is a LineString, remove all Polygons from the Polygons table.
            // If the Way's geometry is a Polygon, remove all LineString from the LineStrings table.
            // This is for preventing duplicated Way geometries. For example, when the Way was a
            // LineString but it was then closed and converted to a Polygon.
            std::string delquery = "DELETE FROM %s WHERE osm_id=%d;";
            boost::format delquery_fmt(delquery);
            if (tableName == &QueryRaw::polyTable) {
                log_debug("Delete Way %1% from table %2%", way.id, QueryRaw::lineTable);
                delquery_fmt % QueryRaw::lineTable;
            } else {
                log_debug("Delete Way %1% from table %2%", way.id, QueryRaw::polyTable);
                delquery_fmt % QueryRaw::polyTable;
            }
            delquery_fmt % way.id;
            queries->push_back(delquery_fmt.str());
        }
    } else if (way.action == osmobjects::remove) {

        // Delete a Way geometry
        log_debug("Delete Way %1%", way.id);
        queries->push_back("DELETE FROM " + QueryRaw::polyTable + " WHERE osm_id = " + std::to_string(way.id) + ";");
        queries->push_back("DELETE FROM " + QueryRaw::lineTable + " WHERE osm_id = " + std::to_string(way.id) + ";");
    }

    return queries;
}

// Apply the change for a Relation.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmRelation &relation) const
{
    auto queries = std::make_shared<std::vector<std::string>>();
    std::string query;

    // Create, modify or modify the geometry of a Relation
    if (relation.action == osmobjects::create || relation.action == osmobjects::modify || relation.action == osmobjects::modify_geom) {

        // Get a Polygon or LineString geometry string depending on the Relation
        std::stringstream ss;
        if (relation.isMultiPolygon()) {
            ss << std::setprecision(12) << bg::wkt(relation.multipolygon);
        } else {
            ss << std::setprecision(12) << bg::wkt(relation.multilinestring);
        }
        std::string geostring = ss.str();

        // Ignore empty geometries
        if (geostring != "MULTILINESTRING()" && geostring != "POLYGON()"
            && geostring != "MULTILINESTRING(())" && geostring != "POLYGON(())") {

            // Insert or update the full Relation, including id, tags, refs, geometry, timestamp,
            // version, user, uid and changeset
            if (relation.action != osmobjects::modify_geom) {

                query = "INSERT INTO relations as r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d)";

                format.append(" ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;");
            
                boost::format fmt(format);

                log_debug("Create or modify Relation %1%", relation.id);

                // osm_id
                fmt % relation.id;

                // tags
                auto tags = utils->buildTagsQuery(relation.tags);
                fmt % tags;

                // refs
                auto refs = utils->buildMembersQuery(relation.members);
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp
                std::string timestamp;
                if (relation.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(relation.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;
                // version
                fmt % relation.version;
                // user
                fmt % dbconn->escapedString(relation.user);
                // uid
                fmt % relation.uid;
                // changeset
                fmt % relation.changeset;

                // ON CONFLICT
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % relation.version;
                fmt % dbconn->escapedString(relation.user);
                fmt % relation.uid;
                fmt % relation.changeset;
                fmt % relation.version;

                query.append(fmt.str());
                queries->push_back(query);

            } else {

                // Update only the Relation's geometry. This is the case when a Relation was indirectly 
                // modified by a change on some referenced Way; the geometry of the Relation will
                // change but all other data (tags, version, etc) will remain the same.

                log_debug("Modify geometry of Relation %1%", relation.id);

                query = "UPDATE relations SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp
                std::string timestamp;
                if (relation.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(relation.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;

                // osm_id
                fmt % relation.id;

                query.append(fmt.str());
                queries->push_back(query);
            }
        }
    } else if (relation.action == osmobjects::remove) {
        log_debug("Delete Relation %1%", relation.id);
        // Delete a Relation geometry and its references.
        queries->push_back("DELETE FROM relations WHERE osm_id = " + std::to_string(relation.id) + ";");
    }

    return queries;
}

// Get functions are for getting OSM features

// Get Relations by referenced Ways ids
std::vector<std::shared_ptr<osmobjects::OsmRelation>>
QueryRaw::getRelationsByWaysRefs(const std::string &wayIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getRelationsByWaysRefs(wayIds): took %w seconds\n");
#endif
    // Object to return
    std::vector<std::shared_ptr<OsmRelation>> rels;

    // Query for getting Relations
    std::string relsQuery = "SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM relations WHERE EXISTS (SELECT 1 FROM jsonb_array_elements(refs) AS ref WHERE (ref->>'ref')::bigint IN (" + wayIds + "));";
    auto rels_result = dbconn->query(relsQuery);

    // Fill vector with OsmRelation objects
    for (auto rel_it = rels_result.begin(); rel_it != rels_result.end(); ++rel_it) {
        auto rel = std::make_shared<osmobjects::OsmRelation>();
        rel->id = (*rel_it)[0].as<long>();
        std::string refs_str = (*rel_it)[1].as<std::string>();
        auto members = utils->parseJSONArrayStr(refs_str);

        for (auto mit = members.begin(); mit != members.end(); ++mit) {
            auto memberType = osmobjects::osmtype_t::way;
            if (mit->at("type") == "n") {
                memberType = osmobjects::osmtype_t::node;
            } else if (mit->at("type") == "r") {
                memberType = osmobjects::osmtype_t::relation;
            }
            rel->addMember(std::stol(mit->at("ref")), memberType, mit->at("role"));
        }

        rel->version = (*rel_it)[2].as<long>();
        auto tags = (*rel_it)[3];
        if (!tags.is_null()) {
            auto tags = utils->parseJSONObjectStr((*rel_it)[3].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                rel->addTag(key, val);
            }
        }
        auto uid = (*rel_it)[4];
        if (!uid.is_null()) {
            rel->uid = (*rel_it)[4].as<long>();
        }
        auto changeset = (*rel_it)[5];
        if (!changeset.is_null()) {
            rel->changeset = (*rel_it)[5].as<long>();
        }
        rels.push_back(rel);
    }
    return rels;
}

// Get Ways by ids
std::vector<std::shared_ptr<osmobjects::OsmWay>>
QueryRaw::getWaysByIds(const std::string &waysIds) const {
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByIds(waysIds): took %w seconds\n");
#endif

    std::vector<std::shared_ptr<osmobjects::OsmWay>> ways;

    // Get Ways and it's geometries (Polygon and LineString)
    std::string waysQuery = "SELECT distinct(osm_id), ST_AsText(geom, 4326), 'polygon' AS type, refs FROM ways_poly wp WHERE osm_id = any(ARRAY[" + waysIds + "]) ";
    waysQuery += "UNION SELECT distinct(osm_id), ST_AsText(geom, 4326), 'linestring' AS type, refs FROM ways_line wp WHERE osm_id = any(ARRAY[" + waysIds + "]);";
    auto ways_result = dbconn->query(waysQuery);
    if (ways_result.size() == 0) {
        log_debug("No results returned!");
        return ways;
    }

    std::string resultIds = "";

    for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
        auto way = std::make_shared<OsmWay>();
        auto type = (*way_it)[2].as<std::string>();
        way->id = (*way_it)[0].as<long>();
        auto geom = (*way_it)[1];
        if (!geom.is_null()) {
            if (type == "polygon") {
                bg::read_wkt((*way_it)[1].as<std::string>(), way->polygon);
            } else {
                bg::read_wkt((*way_it)[1].as<std::string>(), way->linestring);
            }
            auto refs = (*way_it)[3];
            if (!refs.is_null()) {
                std::string refs_str = refs.as<std::string>();
                way->refs = utils->arrayStrToVector(refs_str);
            }
            ways.push_back(way);
        }
    }
    return ways;
}

// Get Nodes by ids
std::vector<std::shared_ptr<osmobjects::OsmNode>>
QueryRaw::getNodesByIds(const std::string &nodeIds) const {
    std::vector<std::shared_ptr<osmobjects::OsmNode>> nodes;
    std::string nodesQuery = "SELECT osm_id, st_x(geom) AS lat, st_y(geom) AS lon FROM nodes WHERE osm_id IN (" + nodeIds + ");";
    auto result = dbconn->query(nodesQuery);
    for (const auto& n : result) {
        auto node_id = n[0].as<long>();
        auto node_lat = n[2].as<double>();
        auto node_lon = n[1].as<double>();
        OsmNode node(node_lat, node_lon);
        node.id = node_id;
        nodes.push_back(std::make_shared<osmobjects::OsmNode>(node));
    }
    return nodes;
}

// Get Nodes by Ways that have references to them
std::vector<std::shared_ptr<osmobjects::OsmNode>>
QueryRaw::getNodesFromWays(const std::shared_ptr<std::vector<OsmWay>> &ways) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getNodeCacheFromWays(ways): took %w seconds\n");
#endif

    // Build a string list of all Nodes ids referenced from Ways
    std::string nodeIds;
    for (auto wit = ways->begin(); wit != ways->end(); ++wit) {
        for (auto rit = std::begin(wit->refs); rit != std::end(wit->refs); ++rit) {
            nodeIds += std::to_string(*rit) + ",";
        }
    }
    if (nodeIds.size() > 1) {
        nodeIds.erase(nodeIds.size() - 1);
    }

    auto nodes = getNodesByIds(nodeIds);
    return nodes;
}

// Get Ways that have Nodes in their references
std::vector<std::shared_ptr<osmobjects::OsmWay>>
QueryRaw::getWaysByNodesRefs(const std::string &nodeIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByNodesRefs(nodeIds): took %w seconds\n");
#endif
    std::vector<std::shared_ptr<osmobjects::OsmWay>> ways;
    std::vector<std::string> queries;

    // Get all Ways that have references to Nodes from the DB, including Polygons and LineString geometries
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM ways_poly WHERE refs && '{" + nodeIds + "}';");
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM ways_line WHERE refs && '{" + nodeIds + "}';");

    for (auto it = queries.begin(); it != queries.end(); ++it) {

        auto ways_result = dbconn->query(*it);
        if (ways_result.size() == 0) {
            log_debug("No results returned!");
            return ways;
        }

        // Create Ways objects and fill the vector
        for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
            auto way = std::make_shared<OsmWay>();
            way->id = (*way_it)[0].as<long>();

            std::string refs_str = (*way_it)[1].as<std::string>();
            if (refs_str.size() > 1) {
                way->refs = utils->arrayStrToVector(refs_str);
            }
            way->version = (*way_it)[2].as<long>();
            auto tags = (*way_it)[3];
            if (!tags.is_null()) {
                auto tags = utils->parseJSONObjectStr((*way_it)[3].as<std::string>());
                for (auto const& [key, val] : tags) {
                    way->addTag(key, val);
                }
            }
            auto uid = (*way_it)[4];
            if (!uid.is_null()) {
                way->uid = (*way_it)[4].as<long>();
            }
            auto changeset = (*way_it)[5];
            if (!changeset.is_null()) {
                way->changeset = (*way_it)[5].as<long>();
            }
            ways.push_back(way);
        }
    }
    return ways;
}

// Utility functions

// Returns latest timestamp from DB - 5 hours
boost::posix_time::ptime
QueryRaw::getLatestTimestamp() {
    auto result = dbconn->query("SELECT MAX(max_timestamp) - INTERVAL '5 hours' FROM ( \
        SELECT MAX(timestamp) AS max_timestamp FROM nodes \
        UNION ALL \
        SELECT MAX(timestamp) FROM ways_line \
        UNION ALL \
        SELECT MAX(timestamp) FROM ways_poly \
        UNION ALL \
        SELECT MAX(timestamp) FROM relations \
        ) AS combined;");
    return utils->cleanTimeStr(result[0][0].as<std::string>());
}

} // namespace queryraw

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
