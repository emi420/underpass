//
// Copyright (c) 2023, 2024 Humanitarian OpenStreetMap Team
// Copyright (c) 2025 Emilio Mariscal
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file queryraw.cc
/// \brief This file is used to work with the OSM Raw database
///
/// This manages the OSM Raw schema in a PostgreSQL database, 
/// including querying existing data in the database, as well as
/// updating the database.

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <map>
#include <string>
#include <iostream>
#include <boost/timer/timer.hpp>
#include <boost/format.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/timer/timer.hpp>
#include "utils/log.hh"
#include "data/pq.hh"
#include "raw/queryraw.hh"
#include "osm/osmobjects.hh"
#include "osm/osmchange.hh"

using namespace pq;
using namespace logger;
using namespace osmobjects;
using namespace osmchange;
namespace bg = boost::geometry;

/// \namespace queryraw
namespace queryraw {

QueryRaw::QueryRaw(std::shared_ptr<Pq> db) {
    dbconn = db;
    utils = std::make_shared<DataUtils>(db);
}

const std::string QueryRaw::polyTable = "ways_poly";
const std::string QueryRaw::lineTable = "ways_line";

// Apply the change for a Node. It will return a string of a query for
// insert, update or delete the Node in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmNode &node) const
{
    auto queries = std::make_shared<std::vector<std::string>>();

    // If create or modify, then insert or update
    if ((node.action == osmobjects::create || node.action == osmobjects::modify)) {
        std::string query = "INSERT INTO nodes AS r (osm_id, geom, tags, timestamp, version, \"user\", uid, changeset) VALUES(";
        std::string format = "%d, ST_GeomFromText(\'%s\', 4326), %s, \'%s\', %d, \'%s\', %d, %d)";

        format.append(" ON CONFLICT (osm_id) DO UPDATE SET geom = ST_GeomFromText(\'%s\', \
        4326), tags = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version < %d;");

        boost::format fmt(format);

        log_debug("Create or modify Node %1%", node.id);

        // osm_id
        fmt % node.id;

        // geometry
        std::stringstream ss;
        ss << std::setprecision(12) << bg::wkt(node.point);
        std::string geometry = ss.str();
        fmt % geometry;

        // tags
        auto tags = utils->buildTagsQuery(node.tags);
        fmt % tags;
        // timestamp
        std::string timestamp;
        if (node.timestamp != not_a_date_time) {
            timestamp = to_simple_string(node.timestamp);
        } else {
            timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
        }

        fmt % timestamp;
        // version
        fmt % node.version;
        // user
        fmt % dbconn->escapedString(node.user);
        // uid
        fmt % node.uid;
        // changeset
        fmt % node.changeset;

        // ON CONFLICT (update)
        fmt % geometry;
        fmt % tags;
        fmt % timestamp;
        fmt % node.version;
        fmt % dbconn->escapedString(node.user);
        fmt % node.uid;
        fmt % node.changeset;
        fmt % node.version;

        query.append(fmt.str());
        queries->push_back(query);

    // If remove, then delete the object
    } else if (node.action == osmobjects::remove) {
        queries->push_back("DELETE FROM nodes WHERE osm_id = " + std::to_string(node.id) + ";");
        log_debug("Delete Node %1%", node.id);
    }

    return queries;
}

// Apply the change for a Way. It will return a string of a query for
// insert, update or delete the Way in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmWay &way) const
{
    auto queries = std::make_shared<std::vector<std::string>>();

    // Make sure we have what's needed to insert or update a Way:
    // - At least 2 points
    // - A LineString or a Polygon
    // - A create, modify or "modify geometry" action.
    if ((bg::num_points(way.linestring) >= 2 || bg::num_points(way.polygon) >= 2)
        && (way.action == osmobjects::create || way.action == osmobjects::modify
        || way.action == osmobjects::modify_geom)) {

        if ((way.refs.front() != way.refs.back() && way.refs.size() == bg::num_points(way.linestring)) ||
            (way.refs.front() == way.refs.back() && way.refs.size() == bg::num_points(way.polygon))
         ) {

            std::string query;
            const std::string* tableName;
            std::stringstream ss;

            // Get a Polygon or LineString geometry string depending on the Way's geometry
            if (way.isClosed()) {
                tableName = &QueryRaw::polyTable;
                ss << std::setprecision(12) << bg::wkt(way.polygon);
            } else {
                tableName = &QueryRaw::lineTable;
                ss << std::setprecision(12) << bg::wkt(way.linestring);
            }
            std::string geostring = ss.str();

            // Insert or update the full Way, including id, tags, refs, geometry, timestamp, version,
            // user, uid and changeset
            if (way.action != osmobjects::modify_geom) {

                log_debug("Create or modify Way %1%", way.id);

                query = "INSERT INTO " + *tableName + " AS r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d)";

                format.append(" ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;");

                boost::format fmt(format);

                // osm_id
                fmt % way.id;

                // tags
                auto tags = utils->buildTagsQuery(way.tags);
                fmt % tags;

                // refs
                std::string refs = "";
                for (auto it = std::begin(way.refs); it != std::end(way.refs); ++it) {
                    refs += std::to_string(*it) + ",";
                }
                refs.erase(refs.size() - 1);
                refs = "ARRAY[" + refs + "]";
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp
                std::string timestamp;
                if (way.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(way.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }

                fmt % timestamp;
                // version
                fmt % way.version;
                // user
                fmt % dbconn->escapedString(way.user);
                // uid
                fmt % way.uid;
                // changeset
                fmt % way.changeset;

                // ON CONFLICT (update)
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % way.version;
                fmt % dbconn->escapedString(way.user);
                fmt % way.uid;
                fmt % way.changeset;
                fmt % way.version;

                query += fmt.str();
                queries->push_back(query);

            } else {

                // Update only the Way's geometry. This is the case when a Way was indirectly 
                // modified by a change on some referenced Node; the geometry of the Way will
                // change but all other data (tags, version, etc) will remain the same.

                log_debug("Modify geometry of Way %1%", way.id);

                query = "UPDATE " + *tableName + " SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp
                std::string timestamp;
                if (way.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(way.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;

                // osm_id
                fmt % way.id;

                query += fmt.str();
                queries->push_back(query);
            }

            // If the Way's geometry is a LineString, remove all Polygons from the Polygons table.
            // If the Way's geometry is a Polygon, remove all LineString from the LineStrings table.
            // This is for preventing duplicated Way geometries. For example, when the Way was a
            // LineString but it was then closed and converted to a Polygon.
            std::string delquery = "DELETE FROM %s WHERE osm_id=%d;";
            boost::format delquery_fmt(delquery);
            if (tableName == &QueryRaw::polyTable) {
                log_debug("Delete Way %1% from table %2%", way.id, QueryRaw::lineTable);
                delquery_fmt % QueryRaw::lineTable;
            } else {
                log_debug("Delete Way %1% from table %2%", way.id, QueryRaw::polyTable);
                delquery_fmt % QueryRaw::polyTable;
            }
            delquery_fmt % way.id;
            queries->push_back(delquery_fmt.str());
        }
    } else if (way.action == osmobjects::remove) {

        // Delete a Way geometry
        log_debug("Delete Way %1%", way.id);
        queries->push_back("DELETE FROM " + QueryRaw::polyTable + " WHERE osm_id = " + std::to_string(way.id) + ";");
        queries->push_back("DELETE FROM " + QueryRaw::lineTable + " WHERE osm_id = " + std::to_string(way.id) + ";");
    }

    return queries;
}

// Apply the change for a Relation. It will return a string of a query for
// insert, update or delete the Relation in the database.
std::shared_ptr<std::vector<std::string>>
QueryRaw::applyChange(const OsmRelation &relation) const
{
    auto queries = std::make_shared<std::vector<std::string>>();
    std::string query;

    // Create, modify or modify the geometry of a Relation
    if (relation.action == osmobjects::create || relation.action == osmobjects::modify || relation.action == osmobjects::modify_geom) {

        // Get a Polygon or LineString geometry string depending on the Relation
        std::stringstream ss;
        if (relation.isMultiPolygon()) {
            ss << std::setprecision(12) << bg::wkt(relation.multipolygon);
        } else {
            ss << std::setprecision(12) << bg::wkt(relation.multilinestring);
        }
        std::string geostring = ss.str();

        // Ignore empty geometries
        if (geostring != "MULTILINESTRING()" && geostring != "POLYGON()"
            && geostring != "MULTILINESTRING(())" && geostring != "POLYGON(())") {

            // Insert or update the full Relation, including id, tags, refs, geometry, timestamp,
            // version, user, uid and changeset
            if (relation.action != osmobjects::modify_geom) {

                query = "INSERT INTO relations as r (osm_id, tags, refs, geom, timestamp, version, \"user\", uid, changeset) VALUES(";
                std::string format = "%d, %s, %s, %s, \'%s\', %d, \'%s\', %d, %d)";

                format.append(" ON CONFLICT (osm_id) DO UPDATE SET tags = %s, refs = %s, geom = %s, timestamp = \'%s\', version = %d, \"user\" = \'%s\', uid = %d, changeset = %d WHERE r.version <= %d;");
            
                boost::format fmt(format);

                log_debug("Create or modify Relation %1%", relation.id);

                // osm_id
                fmt % relation.id;

                // tags
                auto tags = utils->buildTagsQuery(relation.tags);
                fmt % tags;

                // refs
                auto refs = utils->buildMembersQuery(relation.members);
                fmt % refs;

                // geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // timestamp
                std::string timestamp;
                if (relation.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(relation.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;
                // version
                fmt % relation.version;
                // user
                fmt % dbconn->escapedString(relation.user);
                // uid
                fmt % relation.uid;
                // changeset
                fmt % relation.changeset;

                // ON CONFLICT
                fmt % tags;
                fmt % refs;
                fmt % geometry;
                fmt % timestamp;
                fmt % relation.version;
                fmt % dbconn->escapedString(relation.user);
                fmt % relation.uid;
                fmt % relation.changeset;
                fmt % relation.version;

                query.append(fmt.str());
                queries->push_back(query);

            } else {

                // Update only the Relation's geometry. This is the case when a Relation was indirectly 
                // modified by a change on some referenced Way; the geometry of the Relation will
                // change but all other data (tags, version, etc) will remain the same.

                log_debug("Modify geometry of Relation %1%", relation.id);

                query = "UPDATE relations SET ";
                std::string format = "geom=%s, timestamp=\'%s\' WHERE osm_id=%d;";
                boost::format fmt(format);

                // Geometry
                std::string geometry;
                geometry = "ST_GeomFromText(\'" + geostring + "\', 4326)";
                fmt % geometry;

                // Timestamp
                std::string timestamp;
                if (relation.timestamp != not_a_date_time) {
                    timestamp = to_simple_string(relation.timestamp);
                } else {
                    timestamp = to_simple_string(boost::posix_time::second_clock::universal_time());
                }
                fmt % timestamp;

                // osm_id
                fmt % relation.id;

                query.append(fmt.str());
                queries->push_back(query);
            }
        }
    } else if (relation.action == osmobjects::remove) {
        log_debug("Delete Relation %1%", relation.id);
        // Delete a Relation geometry and its references.
        queries->push_back("DELETE FROM relations WHERE osm_id = " + std::to_string(relation.id) + ";");
    }

    return queries;
}

// Get all Relations that have at least 1 reference to any Way
// of a list. This function receives a string of comma separated
// ids ("213213,328947,287313") and returns a list of Relation
// objects. This is useful for getting Relations that were
// indirectly modified by a change on a Way.
std::list<std::shared_ptr<OsmRelation>>
QueryRaw::getRelationsByWaysRefs(std::string &wayIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getRelationsByWaysRefs(wayIds): took %w seconds\n");
#endif
    // Object to return
    std::list<std::shared_ptr<osmobjects::OsmRelation>> rels;

    // Query for getting Relations
    std::string relsQuery = "SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM relations WHERE EXISTS (SELECT 1 FROM jsonb_array_elements(refs) AS ref WHERE (ref->>'ref')::bigint IN (" + wayIds + "));";
    auto rels_result = dbconn->query(relsQuery);

    // Fill vector with OsmRelation objects
    for (auto rel_it = rels_result.begin(); rel_it != rels_result.end(); ++rel_it) {
        auto rel = std::make_shared<OsmRelation>();
        rel->id = (*rel_it)[0].as<long>();
        std::string refs_str = (*rel_it)[1].as<std::string>();
        auto members = utils->parseJSONArrayStr(refs_str);

        for (auto mit = members.begin(); mit != members.end(); ++mit) {
            auto memberType = osmobjects::osmtype_t::way;
            if (mit->at("type") == "n") {
                memberType = osmobjects::osmtype_t::node;
            } else if (mit->at("type") == "r") {
                memberType = osmobjects::osmtype_t::relation;
            }
            rel->addMember(std::stol(mit->at("ref")), memberType, mit->at("role"));
        }

        rel->version = (*rel_it)[2].as<long>();
        auto tags = (*rel_it)[3];
        if (!tags.is_null()) {
            auto tags = utils->parseJSONObjectStr((*rel_it)[3].as<std::string>());
            for (auto const& [key, val] : tags)
            {
                rel->addTag(key, val);
            }
        }
        auto uid = (*rel_it)[4];
        if (!uid.is_null()) {
            rel->uid = (*rel_it)[4].as<long>();
        }
        auto changeset = (*rel_it)[5];
        if (!changeset.is_null()) {
            rel->changeset = (*rel_it)[5].as<long>();
        }
        rels.push_back(rel);
    }
    return rels;
}

// Receives a string with a list of Way ids, get them from the database and store them
// on a Way cache
void
QueryRaw::getWaysByIds(std::string &waysIds, std::map<long, std::shared_ptr<osmobjects::OsmWay>> &waycache) {
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByIds(waysIds, waycache): took %w seconds\n");
#endif
    // Get Ways and it's geometries (Polygon and LineString)
    std::string waysQuery = "SELECT distinct(osm_id), ST_AsText(geom, 4326), 'polygon' AS type, refs FROM ways_poly wp WHERE osm_id = any(ARRAY[" + waysIds + "]) ";
    waysQuery += "UNION SELECT distinct(osm_id), ST_AsText(geom, 4326), 'linestring' AS type, refs FROM ways_line wp WHERE osm_id = any(ARRAY[" + waysIds + "]);";
    auto ways_result = dbconn->query(waysQuery);
    if (ways_result.size() == 0) {
        log_debug("No results returned!");
        return;
    }

    std::string resultIds = "";

    // Insert Ways into waycache
    for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
        auto way = std::make_shared<OsmWay>();
        auto type = (*way_it)[2].as<std::string>();
        way->id = (*way_it)[0].as<long>();
        auto geom = (*way_it)[1];
        if (!geom.is_null()) {
            if (type == "polygon") {
                bg::read_wkt((*way_it)[1].as<std::string>(), way->polygon);
            } else {
                bg::read_wkt((*way_it)[1].as<std::string>(), way->linestring);
            }
            auto refs = (*way_it)[3];
            if (!refs.is_null()) {
                std::string refs_str = refs.as<std::string>();
                way->refs = utils->arrayStrToVector(refs_str);
            }
            waycache.insert(std::pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
        }
    }
}

// Receives a list of Osm Changes and the priority area and completes the geometry of
// all objects (Nodes, Ways and Relations), including all indirectly modified objects.
//
// Incomplete geometries happens all the time on Ways and Relations because the data for
// their geometries (coordinates) can be not present on the OsmChange file. For example
// if the tags of a Way are modified, but not its references, only the tag information
// will be on the OsmChange file, but not the coordinates for the referenced Nodes.
//
// An indirectly modified object is the one whose geometry was modified by a modification
// on the geometry of one of its references. For example, if a Node is modified and that
// Node is referenced on a Way, the Way's geometry must to be updated. Also, if that Way
// is referenced on a Relation, then the Relation's geometry must be updated too.
//
// TODO: divide this function into multiple ones
//
void QueryRaw::buildGeometries(std::shared_ptr<OsmChangeFile> osmchanges, const multipolygon_t &poly)
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("buildGeometries(osmchanges, poly): took %w seconds\n");
#endif
    std::string referencedNodeIds;
    std::string modifiedNodesIds;
    std::string modifiedWaysIds;
    std::vector<long> removedWays;
    std::vector<long> removedRelations;

    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto wit = std::begin(change->ways); wit != std::end(change->ways); ++wit) {
            OsmWay *way = wit->get();

            if (way->action != osmobjects::remove) {

                if (way->action == osmobjects::modify) {
                    modifiedWaysIds += std::to_string(way->id) + ",";
                }

                // Save referenced Nodes ids for later use. The geometries of these
                // Nodes will be needed later when building geometries for Ways
                for (auto rit = std::begin(way->refs); rit != std::end(way->refs); ++rit) {
                    if (!osmchanges->nodecache.count(*rit)) {
                        referencedNodeIds += std::to_string(*rit) + ",";
                    }
                }
                // Save Ways in waycache
                osmchanges->waycache.insert(std::make_pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
            } else {
                // Save removed Ways for later use. This list will be used to known
                // which Ways will be skipped when building geometries
                removedWays.push_back(way->id);
            }
        }

        // Save modified nodes for later use. This list will be used for getting
        // indirectly modified Ways
        for (auto nit = std::begin(change->nodes); nit != std::end(change->nodes); ++nit) {
            OsmNode *node = nit->get();
            if (node->action == osmobjects::modify) {
                // Get only modified nodes ids inside the priority area
                if (poly.empty() || bg::within(node->point, poly)) {
                    modifiedNodesIds += std::to_string(node->id) + ",";
                }
            }
        }

        // Save removed Relations for later use. This list will be used to known
        // which Relations will be skipped when building geometries
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            removedRelations.push_back(relation->id);
        }
    }

    // Add indirectly modified ways to osmchanges. An indirectly modified Way is a Way
    // whose geoemtry was modified because one of it's referenced Nodes was modified
    if (modifiedNodesIds.size() > 1) {
        modifiedNodesIds.erase(modifiedNodesIds.size() - 1);

        // Get all Ways that have at least one reference to one of the modified Nodes
        auto modifiedWays = getWaysByNodesRefs(modifiedNodesIds);

        // Add a new change for the indirectly modified Way
        auto change = std::make_shared<OsmChange>(none);
        for (auto wit = modifiedWays.begin(); wit != modifiedWays.end(); ++wit) {
           auto way = std::make_shared<OsmWay>(*wit->get());
           // If the Way IS NOT removed
           if (std::find(removedWays.begin(), removedWays.end(), way->id) == removedWays.end()) {

                // Save referenced Nodes. This list will be used for getting the geometries of
                // these Nodes, used when building the Way geometry
                for (auto rit = std::begin(way->refs); rit != std::end(way->refs); ++rit) {
                    if (!osmchanges->nodecache.count(*rit)) {
                        referencedNodeIds += std::to_string(*rit) + ",";
                    }
                }

                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                way->action = osmobjects::modify_geom;

                // Add the Way to the list of Ways in the OsmChange
                change->ways.push_back(way);

                // Save the id of the indirectly modified Way for later use. This will be used
                // for identifying which Relations were indirectly modified by this change.
                modifiedWaysIds += std::to_string(way->id) + ",";
           }
        }
        osmchanges->changes.push_back(change);
    }

    // Add indirectly modified Relations to osmchanges. This is the case when a Way referenced
    // in a Relation was modified (or indirectly modified by a change on one of its Nodes)
    if (modifiedWaysIds.size() > 1) {

        // Get indirectly modified Relations from the DB, using the list of Ways
        // that were modified
        modifiedWaysIds.erase(modifiedWaysIds.size() - 1);
        auto modifiedRelations = getRelationsByWaysRefs(modifiedWaysIds);

        // Create a new change for the indirecty modified Relation
        auto change = std::make_shared<OsmChange>(none);
        for (auto rel_it = modifiedRelations.begin(); rel_it != modifiedRelations.end(); ++rel_it) {
           auto relation = std::make_shared<OsmRelation>(*rel_it->get());
           // If the Relation IS NOT removed
           if (std::find(removedRelations.begin(), removedRelations.end(), relation->id) == removedRelations.end()) {
                // Flag it as modified geometry. This means that only the geometry was modified,
                // nor its tags, version, etc.
                relation->action = osmobjects::modify_geom;

                // Add the Relation to the list of Relation in the OsmChange
                change->relations.push_back(relation);
           }
        }
        osmchanges->changes.push_back(change);
    }

    // Fill nodecache with referenced Nodes. This will be used later when building the
    // geometries of Ways
    if (referencedNodeIds.size() > 1) {
        referencedNodeIds.erase(referencedNodeIds.size() - 1);
        // Get Nodes geometries from DB
        std::string nodesQuery = "SELECT osm_id, st_x(geom) AS lat, st_y(geom) AS lon FROM nodes WHERE osm_id IN (" + referencedNodeIds + ");";
        auto result = dbconn->query(nodesQuery);
        if (result.size() > 0) {
            // Fill nodecache
            for (auto node_it = result.begin(); node_it != result.end(); ++node_it) {
                auto node_id = (*node_it)[0].as<long>();
                auto node_lat = (*node_it)[2].as<double>();
                auto node_lon = (*node_it)[1].as<double>();
                OsmNode node(node_lat, node_lon);
                osmchanges->nodecache[node_id] = node.point;
            }
        }
    }

    if (modifiedWaysIds.size() > 1) {
        // Get geometries for all modified Ways
        getWaysByIds(modifiedWaysIds, osmchanges->waycache);
    }

    // Build Ways geometries using nodecache
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto wit = std::begin(change->ways); wit != std::end(change->ways); ++wit) {
            OsmWay *way = wit->get();

            // Only build geometries for Ways with incomplete geometries
            if (bg::num_points(way->linestring) != way->refs.size()) {

                way->linestring.clear();
                for (auto rit = way->refs.begin(); rit != way->refs.end(); ++rit) {
                    if (osmchanges->nodecache.count(*rit)) {
                        bg::append(way->linestring, osmchanges->nodecache.at(*rit));
                    }
                }
                if (way->isClosed()) {
                    way->polygon = { {std::begin(way->linestring), std::end(way->linestring)} };
                    way->linestring.clear();
                }
            }

            // Save Way pointer for later use. This will be used when building Relations geometries.
            if (poly.empty() || bg::within(way->linestring, poly)) {
                if (osmchanges->waycache.count(way->id)) {
                    if (way->isClosed()) {
                        osmchanges->waycache.at(way->id)->polygon = way->polygon;
                    } else {
                        osmchanges->waycache.at(way->id)->linestring = way->linestring;
                    }
                } else {
                    osmchanges->waycache.insert(std::make_pair(way->id, std::make_shared<osmobjects::OsmWay>(*way)));
                }
            }

        }
    }

    // Build list of Relations that have missing geometries. This list will be used for
    // querying the database and get the geometries of the referenced Ways .
    std::string relsForWayCacheIds;
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            if (relation->action != osmobjects::remove) {
                for (auto mit = relation->members.begin(); mit != relation->members.end(); ++mit) {
                    if (mit->type == osmobjects::way && !osmchanges->waycache.count(mit->ref)) {
                        relsForWayCacheIds += std::to_string(mit->ref) + ",";
                    }
                }
            }
        }
    }
    // Get the geometries of the referenced Ways from the DB.
    if (relsForWayCacheIds != "") {
        relsForWayCacheIds.erase(relsForWayCacheIds.size() - 1);
        getWaysByIds(relsForWayCacheIds, osmchanges->waycache);
    }

    // Build geometries for Relations (Polygon or MultiLinestring)
    for (auto it = std::begin(osmchanges->changes); it != std::end(osmchanges->changes); it++) {
        OsmChange *change = it->get();
        for (auto rel_it = std::begin(change->relations); rel_it != std::end(change->relations); ++rel_it) {
            OsmRelation *relation = rel_it->get();
            // Skip removed relations
            if (relation->action != osmobjects::remove) {
                osmchanges->buildRelationGeometry(*relation);
            }
        }
    }
}

// Fill Node cache with Nodes referenced from Ways
void
QueryRaw::getNodeCacheFromWays(std::shared_ptr<std::vector<OsmWay>> ways, std::map<double, point_t> &nodecache) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getNodeCacheFromWays(ways, nodecache): took %w seconds\n");
#endif

    // Build a string list of all Nodes ids referenced from Ways
    std::string nodeIds;
    for (auto wit = ways->begin(); wit != ways->end(); ++wit) {
        for (auto rit = std::begin(wit->refs); rit != std::end(wit->refs); ++rit) {
            nodeIds += std::to_string(*rit) + ",";
        }
    }

    if (nodeIds.size() > 1) {
        nodeIds.erase(nodeIds.size() - 1);

        // Get Nodes geometries from the DB
        std::string nodesQuery = "SELECT osm_id, st_x(geom) AS lat, st_y(geom) AS lon FROM nodes WHERE osm_id IN (" + nodeIds + ") and st_x(geom) IS NOT null AND st_y(geom) IS NOT null;";
        auto result = dbconn->query(nodesQuery);
        if (result.size() == 0) {
            log_debug("No results returned!");
            return;
        }

        // Fill nodecache with Nodes geometries (Points)
        for (auto node_it = result.begin(); node_it != result.end(); ++node_it) {
            auto node_id = (*node_it)[0].as<long>();
            auto node_lat = (*node_it)[1].as<double>();
            auto node_lon = (*node_it)[2].as<double>();
            auto point = point_t(node_lat, node_lon);
            nodecache.insert(std::make_pair(node_id, point));
        }
    }
}

// Receive a string of comma separated values of Nodes ids
// and return a vector of Ways
std::list<std::shared_ptr<OsmWay>>
QueryRaw::getWaysByNodesRefs(std::string &nodeIds) const
{
#ifdef TIMING_DEBUG
    boost::timer::auto_cpu_timer timer("getWaysByNodesRefs(nodeIds): took %w seconds\n");
#endif
    std::list<std::shared_ptr<osmobjects::OsmWay>> ways;
    std::vector<std::string> queries;

    // Get all Ways that have references to Nodes from the DB, including Polygons and LineString geometries
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM ways_poly WHERE refs @> '{" + nodeIds + "}';");
    queries.push_back("SELECT distinct(osm_id), refs, version, tags, uid, changeset FROM ways_line WHERE refs @> '{" + nodeIds + "}';");

    for (auto it = queries.begin(); it != queries.end(); ++it) {

        auto ways_result = dbconn->query(*it);
        if (ways_result.size() == 0) {
            log_debug("No results returned!");
            return ways;
        }

        // Create Ways objects and fill the vector
        for (auto way_it = ways_result.begin(); way_it != ways_result.end(); ++way_it) {
            auto way = std::make_shared<OsmWay>();
            way->id = (*way_it)[0].as<long>();
            std::string refs_str = (*way_it)[1].as<std::string>();
            if (refs_str.size() > 1) {
                way->refs = utils->arrayStrToVector(refs_str);
            }
            way->version = (*way_it)[2].as<long>();
            auto tags = (*way_it)[3];
            if (!tags.is_null()) {
                auto tags = utils->parseJSONObjectStr((*way_it)[3].as<std::string>());
                for (auto const& [key, val] : tags) {
                    way->addTag(key, val);
                }
            }
            auto uid = (*way_it)[4];
            if (!uid.is_null()) {
                way->uid = (*way_it)[4].as<long>();
            }
            auto changeset = (*way_it)[5];
            if (!changeset.is_null()) {
                way->changeset = (*way_it)[5].as<long>();
            }
            ways.push_back(way);
        }
    }
    return ways;
}

// Returns latest timestamp from DB - 5 hours
boost::posix_time::ptime
QueryRaw::getLatestTimestamp() {
    auto result = dbconn->query("SELECT MAX(max_timestamp) - INTERVAL '5 hours' FROM ( \
        SELECT MAX(timestamp) AS max_timestamp FROM nodes \
        UNION ALL \
        SELECT MAX(timestamp) FROM ways_line \
        UNION ALL \
        SELECT MAX(timestamp) FROM ways_poly \
        UNION ALL \
        SELECT MAX(timestamp) FROM relations \
        ) AS combined;");
    return utils->cleanTimeStr(result[0][0].as<std::string>());
}

} // namespace queryraw

// local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
