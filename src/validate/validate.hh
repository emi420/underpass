//
// Copyright (c) 2020, 2021, 2022, 2023 Humanitarian OpenStreetMap Team
//
// This file is part of Underpass.
//
//     Underpass is free software: you can redistribute it and/or modify
//     it under the terms of the GNU General Public License as published by
//     the Free Software Foundation, either version 3 of the License, or
//     (at your option) any later version.
//
//     Underpass is distributed in the hope that it will be useful,
//     but WITHOUT ANY WARRANTY; without even the implied warranty of
//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//     GNU General Public License for more details.
//
//     You should have received a copy of the GNU General Public License
//     along with Underpass.  If not, see <https://www.gnu.org/licenses/>.
//

/// \file validate.hh
/// \brief This class tries to validate the OSM objects
///
/// This class analyzes an OSM object to look for errors. This may
/// include lack of tags on a POI node or a way. This is not an
/// exhaustive test, mostly just a fast sanity-check.

#ifndef __VALIDATE_HH__
#define __VALIDATE_HH__

// This is generated by autoconf
#ifdef HAVE_CONFIG_H
#include "unconfig.h"
#endif

#include <string>
#include <vector>
#include <iostream>
#include <filesystem>
#include <unordered_set>

#include <boost/config.hpp>
#include <boost/geometry.hpp>
#include <boost/date_time.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/dll/runtime_symbol_info.hpp>
#include <boost/timer/timer.hpp>
using namespace boost::posix_time;
using namespace boost::gregorian;

#include "osm/osmobjects.hh"
#include "utils/yaml.hh"
#include "utils/log.hh"
#include "utils/geo.hh"

using namespace logger;

// JOSM validator
//   [ ] Crossing ways
//   [ ] Duplicate Ways
//   [ ] Duplicate nodes
//   [ ] Duplicate relations
//   [ ] Duplicated way nodes
//   [ ] Orphan nodes
//   [x] No square building corners

// OSMInspector
//   [ ] Empty tag key
//   [ ] Unknown highway type
//   [ ] Single node way
//   [ ] Interescting ways

// OSMose
//   [ ] Overlapping buildings
//   [ ] orphan nodes
//   [ ] Duplicate geomtry
//   [ ] Highway not connected
//   [ ] Missing tags
//   [ ] Duplicate object

/// \enum valerror_t
/// The data validation values for the status column in the database.
typedef enum {
    notags,
    complete,
    incomplete,
    badvalue,
    correct,
    badgeom,
    orphan,
    overlapping,
    duplicate,
    valid
} valerror_t;

namespace bg = boost::geometry;
namespace bgm = bg::model;
typedef bgm::polygon<bgm::d2::point_xy<double> > polygon;

/// \class ValidateStatus
/// \brief This class stores data from the validation process
class ValidateStatus {
  public:
    ValidateStatus(void){};
    ValidateStatus(const osmobjects::OsmNode &node) {
        osm_id = node.id;
        uid = node.uid;
        changeset = node.changeset;
        version = node.version;
        objtype = osmobjects::node;
        timestamp = node.timestamp;
    }
    ValidateStatus(const osmobjects::OsmWay &way) {
        osm_id = way.id;
        uid = way.uid;
        changeset = way.changeset;
        objtype = osmobjects::way;
        version = way.version;
        timestamp = way.timestamp;
    }
    ValidateStatus(const osmobjects::OsmRelation &relation) {
        osm_id = relation.id;
        uid = relation.uid;
        changeset = relation.changeset;
        objtype = osmobjects::relation;
        version = relation.version;
        timestamp = relation.timestamp;
    }
    /// Does this change have a particular status value
    bool hasStatus(const valerror_t &val) const {
        auto match = std::find(status.begin(), status.end(), val);
        if (match != status.end()) {
            return true;
        }
        return false;
    }
    /// Dump internal data for debugging
    void dump(void) const {
        std::cerr << "Dumping Validation Statistics" << std::endl;
        std::cerr << "\tOSM ID: " << osm_id << std::endl;
        std::cerr << "\tUser ID: " << uid << std::endl;
        std::cerr << "\tChangeset: " << changeset << std::endl;

        std::map<valerror_t, std::string> results;
        results[notags] = "No tags";
        results[complete] = "Tags are complete";
        results[incomplete] = "Tags are incomplete";
        results[badvalue] = "Bad tag value";
        results[correct] = "Correct tag value";
        results[badgeom] = "Bad geometry";
        results[orphan] = "Orphan";
        results[overlapping] = "Overlap";
        results[duplicate] = "Duplicate";
        for (const auto &stat: std::as_const(status)) {
            std::cerr << "\tResult: " << results[stat] << std::endl;
        }
        if (values.size() > 0) {
            std::cerr << "\tValues: ";
            for (auto it = std::begin(values); it != std::end(values); ++it ) {
                std::cerr << *it << ", " << std::endl;
            }
        }
    }
    std::unordered_set<valerror_t> status;
    osmobjects::osmtype_t objtype;
    long osm_id = 0;        ///< The OSM ID of the feature
    long uid = 0;        ///< The user ID of the mapper creating/modifying this feature
    long changeset = 0;        ///< The changeset ID
    long version = 0;        ///< The object version
    ptime timestamp;        ///< The timestamp when this validation was performed
    point_t center;        ///< The centroid of the building polygon
    std::unordered_set<std::string> values; ///< The found bad tag values
    std::string source; //< The source of the validation status
};


/// \class Validate
/// \brief This class contains shared methods for validating OSM map data
class BOOST_SYMBOL_VISIBLE Validate {
  public:
    Validate(void) {
        std::string path = ETCDIR;
        path += "/validate";
        loadConfig(path);
    }

    void loadConfig(const std::string &path) {
        if (!boost::filesystem::exists(path)) {
            throw std::runtime_error("Validation configuration file not found: " + path);
        }
        for (auto &file: std::filesystem::recursive_directory_iterator(path)) {
            std::filesystem::path config = file.path();
            if (config.extension() == ".yaml") {
                yaml::Yaml yaml;
                yaml.read(config.string());
                if (!config.stem().empty()) {
                    yamls[config.stem()] = yaml;
                }
            }
        }
    }

    virtual ~Validate(void){};

    virtual std::shared_ptr<ValidateStatus> checkNode(const osmobjects::OsmNode &node, const std::string &type) = 0;
    virtual std::shared_ptr<ValidateStatus> checkWay(const osmobjects::OsmWay &way, const std::string &type) = 0;

    yaml::Yaml &operator[](const std::string &key) { return yamls[key]; };
    
    void dump(void) {
        for (auto it = std::begin(yamls); it != std::end(yamls); ++it) {
            it->second.dump();
        }
    }

  protected:
    std::map<std::string, yaml::Yaml> yamls;
};

#endif // EOF __VALIDATE_HH__

// Local Variables:
// mode: C++
// indent-tabs-mode: nil
// End:
